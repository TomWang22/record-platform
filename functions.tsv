Pager usage is off.
Output format is unaligned.
Field separator is "	".
fn	args	definition
public.search_hot_0dc2_cap800_s062	p_q text, p_limit integer, p_offset integer	CREATE OR REPLACE FUNCTION public.search_hot_0dc2_cap800_s062(p_q text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0)
 RETURNS TABLE(id uuid, rank real)
 LANGUAGE sql
 STABLE
 SET gin_fuzzy_search_limit TO '800'
 SET "pg_trgm.similarity_threshold" TO '0.62'
 SET plan_cache_mode TO 'force_custom_plan'
 SET enable_seqscan TO 'off'
 SET enable_bitmapscan TO 'off'
 SET jit TO 'off'
AS $function$
WITH x AS (
  SELECT public.norm_text(coalesce(p_q, '')) AS q
),
cand AS (
  SELECT r.id
  FROM records_poc.records r, x
  WHERE r.user_id = '0dc268d0-a86f-4e12-8d10-9db0f1b735e0'::uuid
    AND r.search_norm % x.q
  LIMIT 800
)
SELECT r.id::uuid AS id,
       (1::real - (r.search_norm <-> x.q)::real) AS rank
FROM cand c
JOIN records_poc.records r ON r.id = c.id
CROSS JOIN x
ORDER BY r.search_norm <-> x.q
LIMIT GREATEST(1, LEAST(1000, p_limit))
OFFSET GREATEST(0, p_offset);
$function$

public.search_hot_0dc2_knn_only	p_q text, p_limit integer, p_offset integer	CREATE OR REPLACE FUNCTION public.search_hot_0dc2_knn_only(p_q text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0)
 RETURNS TABLE(id uuid, rank real)
 LANGUAGE sql
 STABLE
 SET plan_cache_mode TO 'force_custom_plan'
 SET enable_seqscan TO 'off'
 SET enable_bitmapscan TO 'off'
 SET jit TO 'off'
AS $function$
WITH x AS (SELECT public.norm_text(coalesce(p_q,'')) AS q)
SELECT r.id::uuid AS id,
       (1::real - (r.search_norm <-> x.q)::real) AS rank
FROM records_poc.records r, x
WHERE r.user_id = '0dc268d0-a86f-4e12-8d10-9db0f1b735e0'::uuid
ORDER BY r.search_norm <-> x.q
LIMIT GREATEST(1, LEAST(1000, p_limit))
OFFSET GREATEST(0, p_offset);
$function$

public.search_hot_c25_s032	p_q text, p_limit integer, p_offset integer, p_strict boolean	CREATE OR REPLACE FUNCTION public.search_hot_c25_s032(p_q text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0, p_strict boolean DEFAULT false)
 RETURNS TABLE(id uuid, rank real)
 LANGUAGE sql
 STABLE
 SET search_path TO 'public', 'pg_temp'
 SET plan_cache_mode TO 'force_custom_plan'
 SET jit TO 'off'
 SET work_mem TO '65536'
 SET random_page_cost TO '1.0'
 SET enable_seqscan TO 'off'
 SET enable_bitmapscan TO 'off'
 SET enable_indexscan TO 'on'
AS $function$
WITH x AS (SELECT norm_text(coalesce(p_q, '')) AS q),
     base AS (
       -- small KNN shortlist from GiST on the tiny ISO table
       SELECT h.id, (h.search_norm <-> x.q) AS dist
       FROM   records_hot_iso.records_hot_0dc2 h, x
       ORDER  BY 2
       LIMIT  LEAST(300, GREATEST(100, p_limit*6))
     ),
     ranked AS (
       -- OPTIONAL: compute similarity only for the shortlist (heap touch on shortlist only)
       SELECT b.id, b.dist, similarity(h.search_norm, x.q) AS sim
       FROM   base b
       JOIN   records_hot_iso.records_hot_0dc2 h ON h.id = b.id, x
     )
SELECT id,
       (1.0/(1.0+dist))::real AS rank
FROM   ranked
-- If you want a similarity gate, uncomment next line:
-- WHERE  sim >= current_setting('pg_trgm.similarity_threshold')::float
ORDER  BY dist ASC
LIMIT  GREATEST(1, LEAST(1000, p_limit))
OFFSET GREATEST(0, p_offset);
$function$

public.search_hot_c25_s032_knn	p_q text, p_limit integer, p_offset integer, p_strict boolean	CREATE OR REPLACE FUNCTION public.search_hot_c25_s032_knn(p_q text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0, p_strict boolean DEFAULT false)
 RETURNS TABLE(id uuid, rank real)
 LANGUAGE sql
 STABLE
 SET search_path TO 'public', 'pg_temp'
 SET plan_cache_mode TO 'force_custom_plan'
 SET jit TO 'off'
 SET work_mem TO '65536'
 SET random_page_cost TO '1.0'
 SET enable_seqscan TO 'off'
 SET enable_bitmapscan TO 'off'
 SET enable_indexscan TO 'on'
AS $function$
WITH x AS (SELECT norm_text(coalesce(p_q, '')) AS q)
SELECT h.id,
       (1.0/(1.0 + (h.search_norm <-> x.q)))::real AS rank
FROM   records_hot_iso.records_hot_0dc2 h, x
ORDER  BY h.search_norm <-> x.q
LIMIT  GREATEST(1, LEAST(1000, p_limit))
OFFSET GREATEST(0, p_offset);
$function$

public.search_hot_hot_percent_then_knn_adapt	p_user uuid, p_q text, p_limit integer, p_offset integer, p_strict boolean	CREATE OR REPLACE FUNCTION public.search_hot_hot_percent_then_knn_adapt(p_user uuid, p_q text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0, p_strict boolean DEFAULT false)
 RETURNS TABLE(id uuid, rank real)
 LANGUAGE plpgsql
 STABLE
 SET plan_cache_mode TO 'force_custom_plan'
 SET jit TO 'off'
 SET enable_seqscan TO 'off'
 SET enable_bitmapscan TO 'on'
 SET random_page_cost TO '1.0'
 SET work_mem TO '64MB'
AS $function$
DECLARE
  gates numeric[] := ARRAY[0.60,0.58,0.56,0.54,0.52,0.50,0.48,0.46];
  gate  numeric;
  sql   text;
  body  text := $q$
    WITH x AS (
      SELECT set_limit($GATE$) AS _ , public.norm_text(coalesce($1,'')) AS q
    ),
    cand AS (
      SELECT h.id, (h.search_norm <-> x.q) AS dist
      FROM records_hot.records_hot h, x
      WHERE h.user_id = $USER$::uuid
        AND h.search_norm % x.q
        AND similarity(h.search_norm, x.q) >= $GATE$
      ORDER BY 1 ASC
      LIMIT LEAST(600, GREATEST(200, $2*12))
    )
    SELECT id, (1::real - dist::real) AS rank
    FROM cand
    ORDER BY dist ASC
    LIMIT GREATEST(1, LEAST(1000, $2))
    OFFSET GREATEST(0, $3)
  $q$;
BEGIN
  FOREACH gate IN ARRAY gates LOOP
    sql := replace(body, '$USER$', quote_literal(p_user));
    sql := replace(sql, '$GATE$', to_char(gate,'FM0.00'));
    RETURN QUERY EXECUTE sql USING p_q, p_limit, p_offset;
    IF FOUND THEN RETURN; END IF;
  END LOOP;

  -- Final fallback: your existing pure KNN wrapper (hot heap)
  RETURN QUERY
  WITH x AS (SELECT public.norm_text(coalesce(p_q,'')) AS q)
  SELECT h.id, (1::real - (h.search_norm <-> x.q)::real) AS rank
  FROM records_hot.records_hot h, x
  WHERE h.user_id = p_user
  ORDER BY h.search_norm <-> x.q
  LIMIT GREATEST(1, LEAST(1000, p_limit))
  OFFSET GREATEST(0, p_offset);
END
$function$

public.search_hot_knn_only	p_user uuid, p_q text, p_limit integer, p_offset integer, p_strict boolean	CREATE OR REPLACE FUNCTION public.search_hot_knn_only(p_user uuid, p_q text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0, p_strict boolean DEFAULT false)
 RETURNS TABLE(id uuid, rank real)
 LANGUAGE plpgsql
 STABLE
 SET plan_cache_mode TO 'force_custom_plan'
 SET enable_seqscan TO 'off'
 SET enable_bitmapscan TO 'off'
 SET jit TO 'off'
 SET random_page_cost TO '1.0'
AS $function$
DECLARE
  use_hot boolean;
BEGIN
  use_hot := (to_regclass('records_hot.records_hot') IS NOT NULL)
             AND EXISTS (SELECT 1 FROM records_hot.records_hot WHERE user_id = p_user LIMIT 1);

  IF use_hot THEN
    RETURN QUERY
    WITH x AS (SELECT public.norm_text(coalesce(p_q,'')) AS q)
    SELECT h.id, (1::real - (h.search_norm <-> x.q)::real) AS rank
    FROM records_hot.records_hot h, x
    WHERE h.user_id = p_user
    ORDER BY h.search_norm <-> x.q
    LIMIT GREATEST(1, LEAST(1000, p_limit))
    OFFSET GREATEST(0, p_offset);
  ELSE
    RETURN QUERY
    WITH x AS (SELECT public.norm_text(coalesce(p_q,'')) AS q)
    SELECT r.id, (1::real - (r.search_norm <-> x.q)::real) AS rank
    FROM records.records r, x
    WHERE r.user_id = p_user
    ORDER BY r.search_norm <-> x.q
    LIMIT GREATEST(1, LEAST(1000, p_limit))
    OFFSET GREATEST(0, p_offset);
  END IF;
END
$function$

public.search_hot_main_c25_s032	p_q text, p_limit integer, p_offset integer, p_strict boolean	CREATE OR REPLACE FUNCTION public.search_hot_main_c25_s032(p_q text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0, p_strict boolean DEFAULT false)
 RETURNS TABLE(id uuid, rank real)
 LANGUAGE sql
 STABLE
 SET "pg_trgm.similarity_threshold" TO '0.32'
 SET plan_cache_mode TO 'force_custom_plan'
 SET jit TO 'off'
 SET random_page_cost TO '1.1'
AS $function$
  WITH x AS (SELECT public.norm_text(coalesce(p_q,'')) AS q)
  SELECT r.id,
         (1::real - (r.search_norm <-> x.q)::real) AS rank
  FROM records.records r, x
  WHERE r.user_id = '0dc268d0-a86f-4e12-8d10-9db0f1b735e0'::uuid
    AND r.search_norm % x.q
  ORDER BY r.search_norm <-> x.q
  LIMIT GREATEST(1, LEAST(1000, p_limit))
  OFFSET GREATEST(0, p_offset)
$function$

public.search_hot_main_c25_s032_fast	p_q text, p_limit integer, p_offset integer, p_strict boolean	CREATE OR REPLACE FUNCTION public.search_hot_main_c25_s032_fast(p_q text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0, p_strict boolean DEFAULT false)
 RETURNS TABLE(id uuid, rank real)
 LANGUAGE sql
 STABLE
 SET "pg_trgm.similarity_threshold" TO '0.32'
 SET plan_cache_mode TO 'force_custom_plan'
 SET jit TO 'off'
 SET work_mem TO '64MB'
 SET random_page_cost TO '1.0'
AS $function$
  WITH x AS (SELECT public.norm_text(coalesce(p_q,'')) AS q),
  cand AS (
    SELECT r.id, similarity(r.search_norm, x.q) AS sim
    FROM records.records r, x
    WHERE r.user_id = '0dc268d0-a86f-4e12-8d10-9db0f1b735e0'::uuid     -- tenant-pinned
      AND r.search_norm % x.q                  -- hits GIN
    ORDER BY sim DESC
    LIMIT LEAST(1000, GREATEST(100, p_limit*20))  -- shortlist ~20× limit
  )
  SELECT id, sim::real AS rank
  FROM cand
  ORDER BY sim DESC
  LIMIT GREATEST(1, LEAST(1000, p_limit))
  OFFSET GREATEST(0, p_offset)
$function$

public.search_hot_main_c25_s032_gin_then_knn	p_q text, p_limit integer, p_offset integer, p_strict boolean	CREATE OR REPLACE FUNCTION public.search_hot_main_c25_s032_gin_then_knn(p_q text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0, p_strict boolean DEFAULT false)
 RETURNS TABLE(id uuid, rank real)
 LANGUAGE sql
 STABLE
 SET "pg_trgm.similarity_threshold" TO '0.32'
 SET plan_cache_mode TO 'force_custom_plan'
 SET jit TO 'off'
 SET work_mem TO '64MB'
 SET random_page_cost TO '1.0'
AS $function$
  WITH x AS (SELECT public.norm_text(coalesce(p_q,'')) AS q),
  cand AS (
    SELECT r.id,
           similarity(r.search_norm, x.q) AS sim,
           (r.search_norm <-> x.q)        AS dist
    FROM records.records r, x
    WHERE r.user_id = '0dc268d0-a86f-4e12-8d10-9db0f1b735e0'::uuid
      AND r.search_norm % x.q
    ORDER BY sim DESC
    LIMIT LEAST(1000, GREATEST(100, p_limit*20))
  )
  SELECT id, (1::real - dist::real) AS rank
  FROM cand
  ORDER BY dist ASC                  -- KNN tie-break over shortlist
  LIMIT GREATEST(1, LEAST(1000, p_limit))
  OFFSET GREATEST(0, p_offset)
$function$

public.search_hot_main_c25_s032_knn	p_q text, p_limit integer, p_offset integer, p_strict boolean	CREATE OR REPLACE FUNCTION public.search_hot_main_c25_s032_knn(p_q text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0, p_strict boolean DEFAULT false)
 RETURNS TABLE(id uuid, rank real)
 LANGUAGE sql
 STABLE
 SET plan_cache_mode TO 'force_custom_plan'
 SET jit TO 'off'
 SET random_page_cost TO '1.1'
AS $function$
  WITH x AS (SELECT public.norm_text(coalesce(p_q,'')) AS q)
  SELECT r.id,
         (1::real - (r.search_norm <-> x.q)::real) AS rank
  FROM records.records r, x
  WHERE r.user_id = '0dc268d0-a86f-4e12-8d10-9db0f1b735e0'::uuid
  ORDER BY r.search_norm <-> x.q
  LIMIT GREATEST(1, LEAST(1000, p_limit))
  OFFSET GREATEST(0, p_offset)
$function$

public.search_hot_main_c25_s036_fast	p_q text, p_limit integer, p_offset integer, p_strict boolean	CREATE OR REPLACE FUNCTION public.search_hot_main_c25_s036_fast(p_q text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0, p_strict boolean DEFAULT false)
 RETURNS TABLE(id uuid, rank real)
 LANGUAGE sql
 STABLE
 SET "pg_trgm.similarity_threshold" TO '0.36'
 SET plan_cache_mode TO 'force_custom_plan'
 SET jit TO 'off'
 SET work_mem TO '64MB'
 SET random_page_cost TO '1.0'
AS $function$
  WITH x AS (SELECT public.norm_text(coalesce(p_q,'')) AS q),
  cand AS (
    SELECT r.id, similarity(r.search_norm, x.q) AS sim
    FROM records.records r, x
    WHERE r.user_id = '0dc268d0-a86f-4e12-8d10-9db0f1b735e0'::uuid
      AND r.search_norm % x.q
    ORDER BY sim DESC
    LIMIT LEAST(1000, GREATEST(300, p_limit*12))
  )
  SELECT id, sim::real AS rank
  FROM cand
  ORDER BY sim DESC
  LIMIT GREATEST(1, LEAST(1000, p_limit))
  OFFSET GREATEST(0, p_offset)
$function$

public.search_hot_main_c25_s036_gin_then_knn	p_q text, p_limit integer, p_offset integer, p_strict boolean	CREATE OR REPLACE FUNCTION public.search_hot_main_c25_s036_gin_then_knn(p_q text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0, p_strict boolean DEFAULT false)
 RETURNS TABLE(id uuid, rank real)
 LANGUAGE sql
 STABLE
 SET "pg_trgm.similarity_threshold" TO '0.36'
 SET plan_cache_mode TO 'force_custom_plan'
 SET jit TO 'off'
 SET work_mem TO '64MB'
 SET random_page_cost TO '1.0'
AS $function$
  WITH x AS (SELECT public.norm_text(coalesce(p_q,'')) AS q),
  cand AS (
    SELECT r.id, (r.search_norm <-> x.q) AS dist
    FROM records.records r, x
    WHERE r.user_id = '0dc268d0-a86f-4e12-8d10-9db0f1b735e0'::uuid
      AND r.search_norm % x.q
    ORDER BY 1 ASC
    LIMIT LEAST(1000, GREATEST(300, p_limit*12))
  )
  SELECT id, (1::real - dist::real) AS rank
  FROM cand
  ORDER BY dist ASC
  LIMIT GREATEST(1, LEAST(1000, p_limit))
  OFFSET GREATEST(0, p_offset)
$function$

public.search_hot_official	p_q text, p_limit integer, p_offset integer	CREATE OR REPLACE FUNCTION public.search_hot_official(p_q text, p_limit integer, p_offset integer)
 RETURNS TABLE(id uuid, rank real)
 LANGUAGE sql
 STABLE
 SET plan_cache_mode TO 'force_custom_plan'
 SET jit TO 'off'
 SET work_mem TO '64MB'
 SET "pg_trgm.similarity_threshold" TO '0.42'
 SET gin_fuzzy_search_limit TO '300'
AS $function$
  WITH x AS (SELECT public.norm_text(coalesce(p_q, '')) AS q),
  cand AS (
    SELECT h.id,
           (h.search_norm <-> x.q) AS dist
    FROM records_hot.records_hot h, x
    WHERE h.user_id = '0dc268d0-a86f-4e12-8d10-9db0f1b735e0'::uuid
      AND h.search_norm % x.q
    ORDER BY (h.search_norm <-> x.q) ASC
    LIMIT LEAST(400, GREATEST(200, p_limit*8))
  )
  SELECT id, (1::real - dist::real) AS rank
  FROM cand
  -- already ordered by dist ASC; omit outer ORDER BY to avoid re-sort
  LIMIT  GREATEST(1, LEAST(1000, p_limit))
  OFFSET GREATEST(0, p_offset)
$function$

public.search_hot_official_count	p_q text, p_limit integer, p_offset integer	CREATE OR REPLACE FUNCTION public.search_hot_official_count(p_q text, p_limit integer, p_offset integer)
 RETURNS integer
 LANGUAGE sql
 STABLE
 SET plan_cache_mode TO 'force_custom_plan'
 SET jit TO 'off'
 SET work_mem TO '64MB'
 SET "pg_trgm.similarity_threshold" TO '0.42'
 SET gin_fuzzy_search_limit TO '300'
AS $function$
  WITH x AS (SELECT public.norm_text(coalesce(p_q, '')) AS q),
  cand AS (
    SELECT h.id,
           (h.search_norm <-> x.q) AS dist
    FROM records_hot.records_hot h, x
    WHERE h.user_id = '0dc268d0-a86f-4e12-8d10-9db0f1b735e0'::uuid
      AND h.search_norm % x.q
    ORDER BY (h.search_norm <-> x.q) ASC
    LIMIT LEAST(400, GREATEST(200, p_limit*8))
  )
  SELECT count(*)
  FROM (
    SELECT id
    FROM cand
    -- already KNN-ordered; just respect limit/offset
    LIMIT  GREATEST(1, LEAST(1000, p_limit))
    OFFSET GREATEST(0, p_offset)
  ) s
$function$

public.search_hot_official_count_norm	p_q_norm text, p_limit integer, p_offset integer	CREATE OR REPLACE FUNCTION public.search_hot_official_count_norm(p_q_norm text, p_limit integer, p_offset integer)
 RETURNS integer
 LANGUAGE sql
 STABLE
 SET plan_cache_mode TO 'force_custom_plan'
 SET jit TO 'off'
 SET work_mem TO '64MB'
 SET random_page_cost TO '1.0'
 SET enable_seqscan TO 'off'
 SET enable_indexscan TO 'off'
 SET enable_bitmapscan TO 'on'
 SET "pg_trgm.similarity_threshold" TO '0.40'
 SET gin_fuzzy_search_limit TO '400'
AS $function$
  WITH x AS (SELECT coalesce(p_q_norm, '') AS q),
  cand AS (
    -- GIN % shortlist + ORDER BY similarity (cheap) + LIMIT
    SELECT h.id,
           similarity(h.search_norm, x.q) AS sim,
           (h.search_norm <-> x.q)        AS dist
    FROM records_hot_iso.records_hot_0dc2 h, x
    WHERE h.search_norm % x.q
    ORDER BY sim DESC
    LIMIT LEAST(300, GREATEST(150, p_limit*6))
  )
  SELECT count(*)
  FROM (
    -- final KNN reorder of tiny set
    SELECT id
    FROM cand
    ORDER BY dist ASC
    LIMIT  GREATEST(1, LEAST(1000, p_limit))
    OFFSET GREATEST(0, p_offset)
  ) s
$function$

public.search_hot_official_knn	p_q text, p_limit integer, p_offset integer	CREATE OR REPLACE FUNCTION public.search_hot_official_knn(p_q text, p_limit integer, p_offset integer)
 RETURNS TABLE(id uuid, rank real)
 LANGUAGE sql
 STABLE
 SET plan_cache_mode TO 'force_custom_plan'
 SET jit TO 'off'
AS $function$
  SELECT * FROM public.search_hot_main_c25_s032_knn(p_q, p_limit, p_offset, false)
$function$

public.search_hot_official_knn_count	p_q text, p_limit integer, p_offset integer	CREATE OR REPLACE FUNCTION public.search_hot_official_knn_count(p_q text, p_limit integer, p_offset integer)
 RETURNS integer
 LANGUAGE sql
 STABLE
AS $function$SELECT count(*) FROM public.search_hot_official_knn(p_q, p_limit, p_offset)$function$

public.search_hot_official_norm	p_q_norm text, p_limit integer, p_offset integer	CREATE OR REPLACE FUNCTION public.search_hot_official_norm(p_q_norm text, p_limit integer, p_offset integer)
 RETURNS TABLE(id uuid, rank real)
 LANGUAGE sql
 STABLE
 SET plan_cache_mode TO 'force_custom_plan'
 SET jit TO 'off'
 SET work_mem TO '64MB'
 SET "pg_trgm.similarity_threshold" TO '0.42'
 SET gin_fuzzy_search_limit TO '300'
AS $function$
  WITH x AS (SELECT coalesce(p_q_norm, '') AS q),
  cand AS (
    SELECT h.id, (h.search_norm <-> x.q) AS dist
    FROM records_hot.records_hot h, x
    WHERE h.user_id = '0dc268d0-a86f-4e12-8d10-9db0f1b735e0'::uuid
      AND h.search_norm % x.q
    ORDER BY (h.search_norm <-> x.q) ASC
    LIMIT LEAST(400, GREATEST(200, p_limit*8))
  )
  SELECT id, (1::real - dist::real) AS rank
  FROM cand
  LIMIT  GREATEST(1, LEAST(1000, p_limit))
  OFFSET GREATEST(0, p_offset)
$function$

public.search_hot_official_s032	p_q text, p_limit integer, p_offset integer	CREATE OR REPLACE FUNCTION public.search_hot_official_s032(p_q text, p_limit integer, p_offset integer)
 RETURNS TABLE(id uuid, rank real)
 LANGUAGE sql
 STABLE
 SET plan_cache_mode TO 'force_custom_plan'
 SET jit TO 'off'
AS $function$
  SELECT * FROM public.search_hot_main_c25_s036_fast(p_q, p_limit, p_offset, false)
$function$

public.search_hot_official_s032_count	p_q text, p_limit integer, p_offset integer	CREATE OR REPLACE FUNCTION public.search_hot_official_s032_count(p_q text, p_limit integer, p_offset integer)
 RETURNS integer
 LANGUAGE sql
 STABLE
AS $function$SELECT count(*) FROM public.search_hot_official_s032(p_q, p_limit, p_offset)$function$

public.search_hot_official_super	p_q text, p_limit integer, p_offset integer	CREATE OR REPLACE FUNCTION public.search_hot_official_super(p_q text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0)
 RETURNS TABLE(id uuid, rank real)
 LANGUAGE sql
 STABLE
 SET gin_fuzzy_search_limit TO '800'
 SET "pg_trgm.similarity_threshold" TO '0.52'
 SET plan_cache_mode TO 'force_custom_plan'
 SET enable_seqscan TO 'off'
 SET enable_bitmapscan TO 'off'
 SET jit TO 'off'
AS $function$
WITH x AS (SELECT public.norm_text(coalesce(p_q,'')) AS q),
caps AS (
  SELECT 800::int AS cap, 400::int AS half
),
trig AS (
  SELECT r.id, 1 AS src
  FROM records_poc.records r, x, caps
  WHERE r.user_id = '0dc268d0-a86f-4e12-8d10-9db0f1b735e0'::uuid
    AND r.search_norm % x.q
  LIMIT (SELECT cap FROM caps)
),
ali AS (
  SELECT a.record_id AS id, 2 AS src
  FROM records.aliases_mv a, x, caps
  WHERE a.user_id = '0dc268d0-a86f-4e12-8d10-9db0f1b735e0'::uuid
    AND a.alias_norm % x.q
  LIMIT (SELECT half FROM caps)
),
ftsq AS (
  SELECT websearch_to_tsquery('simple', x.q) AS qts FROM x
),
fts AS (
  SELECT s.id, 3 AS src
  FROM records.search_doc_mv s, ftsq, caps
  WHERE s.user_id = '0dc268d0-a86f-4e12-8d10-9db0f1b735e0'::uuid
    AND s.sv @@ ftsq.qts
  ORDER BY ts_rank(s.sv, ftsq.qts) DESC
  LIMIT (SELECT half FROM caps)
),
bag AS (
  SELECT * FROM trig
  UNION ALL SELECT * FROM ali
  UNION ALL SELECT * FROM fts
),
cand AS MATERIALIZED (
  SELECT id,
         bool_or(src=2) AS hit_alias,
         bool_or(src=3) AS hit_fts
  FROM bag
  GROUP BY id
  LIMIT (SELECT cap FROM caps)
)
SELECT r.id::uuid AS id,
       ((1::real - (r.search_norm <-> x.q)::real)
           + CASE WHEN c.hit_alias THEN 0.02 ELSE 0 END
           + CASE WHEN c.hit_fts   THEN 0.04 ELSE 0 END)::real AS rank
FROM cand c
JOIN records_poc.records r USING (id)
CROSS JOIN x
ORDER BY r.search_norm <-> x.q
LIMIT GREATEST(1, LEAST(1000, p_limit))
OFFSET GREATEST(0, p_offset);
$function$

public.search_hot_percent_then_knn	p_user uuid, p_q text, p_limit integer, p_offset integer, p_strict boolean	CREATE OR REPLACE FUNCTION public.search_hot_percent_then_knn(p_user uuid, p_q text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0, p_strict boolean DEFAULT false)
 RETURNS TABLE(id uuid, rank real)
 LANGUAGE plpgsql
 STABLE
 SET plan_cache_mode TO 'force_custom_plan'
 SET enable_seqscan TO 'off'
 SET enable_bitmapscan TO 'off'
 SET jit TO 'off'
 SET work_mem TO '64MB'
 SET random_page_cost TO '1.0'
AS $function$
DECLARE
  sql text;
BEGIN
  sql := $q$
    WITH x AS (SELECT public.norm_text(coalesce($1,'')) AS q),
    cand AS (
      SELECT r.id, (r.search_norm <-> x.q) AS dist
      FROM records.records r, x
      WHERE r.user_id = $USER_LIT$
        AND r.search_norm % x.q
      ORDER BY 1 ASC
      LIMIT LEAST(1000, GREATEST(300, $2*12))
    )
    SELECT id, (1::real - dist::real) AS rank
    FROM cand
    ORDER BY dist ASC
    LIMIT GREATEST(1, LEAST(1000, $2))
    OFFSET GREATEST(0, $3)
  $q$;

  sql := replace(sql, '$USER_LIT$', quote_literal(p_user) || '::uuid');

  RETURN QUERY EXECUTE sql USING p_q, p_limit, p_offset;
END
$function$

public.search_hot_percent_then_knn_adapt	p_user uuid, p_q text, p_limit integer, p_offset integer, p_strict boolean	CREATE OR REPLACE FUNCTION public.search_hot_percent_then_knn_adapt(p_user uuid, p_q text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0, p_strict boolean DEFAULT false)
 RETURNS TABLE(id uuid, rank real)
 LANGUAGE plpgsql
 STABLE
 SET plan_cache_mode TO 'force_custom_plan'
 SET enable_seqscan TO 'off'
 SET enable_bitmapscan TO 'off'
 SET jit TO 'off'
 SET work_mem TO '64MB'
 SET random_page_cost TO '1.0'
AS $function$
DECLARE
  gates real[] := ARRAY[0.60, 0.58, 0.56, 0.54, 0.52];
  gate  real;
  cap   int := 400;   -- cap shortlist
  base  int := 10;    -- shortlist ≈ base×limit
  tname text;
  use_hot boolean;
  sql   text;
BEGIN
  use_hot := (to_regclass('records_hot.records_hot') IS NOT NULL)
             AND EXISTS (SELECT 1 FROM records_hot.records_hot WHERE user_id = p_user LIMIT 1);
  tname := CASE WHEN use_hot THEN 'records_hot.records_hot' ELSE 'records.records' END;

  FOREACH gate IN ARRAY gates LOOP
    sql := 'WITH x AS (
              SELECT set_limit($4) AS _, public.norm_text(coalesce($1, '''')) AS q
            ),
            cand AS (
              SELECT h.id, (h.search_norm <-> x.q) AS dist
              FROM '||tname||' h, x
              WHERE h.user_id = $5
                AND h.search_norm % x.q
                AND similarity(h.search_norm, x.q) >= $4
              ORDER BY 1 ASC
              LIMIT LEAST($6, GREATEST(200, $2*$7))
            )
            SELECT id, (1::real - dist::real) AS rank
            FROM cand
            ORDER BY dist ASC
            LIMIT GREATEST(1, LEAST(1000, $2))
            OFFSET GREATEST(0, $3)';

    RETURN QUERY EXECUTE sql USING
      p_q,           -- $1
      p_limit,       -- $2
      p_offset,      -- $3
      gate,          -- $4 (set_limit & similarity gate)
      p_user,        -- $5
      cap,           -- $6
      base;          -- $7

    IF FOUND THEN
      RETURN;
    END IF;
  END LOOP;

  -- last resort
  RETURN QUERY SELECT * FROM public.search_hot_knn_only(p_user, p_q, p_limit, p_offset, p_strict);
END
$function$

public.search_hot_percent_then_knn_safe	p_user uuid, p_q text, p_limit integer, p_offset integer, p_strict boolean	CREATE OR REPLACE FUNCTION public.search_hot_percent_then_knn_safe(p_user uuid, p_q text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0, p_strict boolean DEFAULT false)
 RETURNS TABLE(id uuid, rank real)
 LANGUAGE plpgsql
 STABLE
 SET plan_cache_mode TO 'force_custom_plan'
 SET jit TO 'off'
 SET work_mem TO '64MB'
 SET random_page_cost TO '1.0'
AS $function$
DECLARE
  sql text;
  rows int;
BEGIN
  -- 1st pass: tighter shortlist
  sql := '
    WITH x AS (
      SELECT set_limit(0.52) AS _, public.norm_text(coalesce($1, '''')) AS q
    ),
    cand AS (
      SELECT r.id, (r.search_norm <-> x.q) AS dist
      FROM records.records r, x
      WHERE r.user_id = ' || quote_literal(p_user)::text || '::uuid
        AND r.search_norm % x.q
        AND similarity(r.search_norm, x.q) >= 0.52
      ORDER BY dist ASC
      LIMIT 400
    )
    SELECT id, (1::real - dist::real) AS rank
    FROM cand
    ORDER BY dist ASC
    LIMIT GREATEST(1, LEAST(1000, $2))
    OFFSET GREATEST(0, $3)
  ';
  RETURN QUERY EXECUTE sql USING p_q, p_limit, p_offset;
  GET DIAGNOSTICS rows = ROW_COUNT;

  IF rows = 0 THEN
    -- Fallback: slightly looser
    sql := replace(sql, '0.52', '0.50');
    RETURN QUERY EXECUTE sql USING p_q, p_limit, p_offset;
  END IF;
END
$function$

public.search_hot_poc_c25_s032	p_q text, p_limit integer, p_offset integer, p_strict boolean	CREATE OR REPLACE FUNCTION public.search_hot_poc_c25_s032(p_q text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0, p_strict boolean DEFAULT false)
 RETURNS TABLE(id uuid, rank real)
 LANGUAGE sql
 STABLE
 SET "pg_trgm.similarity_threshold" TO '0.32'
 SET plan_cache_mode TO 'force_custom_plan'
 SET jit TO 'off'
AS $function$
  WITH x AS (SELECT public.norm_text(coalesce(p_q,'')) AS q)
  SELECT r.id,
         (1::real - (r.search_norm <-> x.q)::real) AS rank
  FROM records_poc.records r, x
  WHERE r.search_norm % x.q
  ORDER BY r.search_norm <-> x.q
  LIMIT GREATEST(1, LEAST(1000, p_limit))
  OFFSET GREATEST(0, p_offset)
$function$

public.search_hot_poc_c25_s032_knn	p_q text, p_limit integer, p_offset integer, p_strict boolean	CREATE OR REPLACE FUNCTION public.search_hot_poc_c25_s032_knn(p_q text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0, p_strict boolean DEFAULT false)
 RETURNS TABLE(id uuid, rank real)
 LANGUAGE sql
 STABLE
 SET plan_cache_mode TO 'force_custom_plan'
 SET jit TO 'off'
AS $function$
  WITH x AS (SELECT public.norm_text(coalesce(p_q,'')) AS q)
  SELECT r.id,
         (1::real - (r.search_norm <-> x.q)::real) AS rank
  FROM records_poc.records r, x
  ORDER BY r.search_norm <-> x.q
  LIMIT GREATEST(1, LEAST(1000, p_limit))
  OFFSET GREATEST(0, p_offset)
$function$

(26 rows)
