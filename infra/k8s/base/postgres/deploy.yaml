apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
  labels: { app: postgres }
spec:
  replicas: 1
  selector: { matchLabels: { app: postgres } }
  template:
    metadata: { labels: { app: postgres } }
    spec:
      securityContext:
        runAsUser: 70
        runAsGroup: 70
        fsGroup: 70
        fsGroupChangePolicy: OnRootMismatch
      # Init containers: prepare directories with correct permissions
      initContainers:
        # prep-dirs: runs as uid 70, just ensures dirs exist (host PVC already owned by 70:70)
        - name: prep-dirs
          image: busybox:1.36
          command: ["/bin/sh","-lc"]
          args:
            - |
              set -eux
              # just ensure dirs exist; do NOT chown here (host already fixed to 70:70)
              mkdir -p /var/run/postgresql /var/lib/postgresql/data
              chmod 0775 /var/run/postgresql || true
              ls -ld /var/lib/postgresql /var/lib/postgresql/data /wal-archive /var/run/postgresql || true
          securityContext:
            runAsUser: 70
            runAsGroup: 70
            allowPrivilegeEscalation: false
          volumeMounts:
            - { name: data,        mountPath: /var/lib/postgresql }
            - { name: wal-archive, mountPath: /wal-archive }
            - { name: run,         mountPath: /var/run/postgresql }
          terminationMessagePolicy: FallbackToLogsOnError
        # ensure-db: ensures records database exists (runs after postgres is up)
        # Note: This runs as a sidecar approach - we'll use a postStart hook instead

      containers:
      - name: db
        image: postgres:16-alpine
        resources:
          requests:
            memory: "6Gi"
            cpu: "500m"
          limits:
            memory: "12Gi"
            cpu: "2000m"
        env:
        # POSTGRES_DB: Only create database if it doesn't exist (Postgres checks this)
        # This prevents reinitialization if database already exists on PVC
        - { name: POSTGRES_USER, value: "postgres" }
        - { name: POSTGRES_DB,   value: "records" }
        - { name: PGDATA,        value: "/var/lib/postgresql/data" }
        envFrom:
        - { secretRef: { name: postgres-superuser } }
        ports:
        - { name: pg, containerPort: 5432 }
        readinessProbe:
          exec: { command: ["sh","-lc","pg_isready -U postgres -h 127.0.0.1 -p 5432"] }
          initialDelaySeconds: 5
          periodSeconds: 5
        livenessProbe:
          exec: { command: ["sh","-lc","pg_isready -U postgres -h 127.0.0.1 -p 5432"] }
          initialDelaySeconds: 10
          periodSeconds: 10
        lifecycle:
          postStart:
            exec:
              command:
                - /bin/sh
                - -c
                - |
                  # Wait for postgres to be ready, then ensure records database exists
                  sleep 10
                  for i in $(seq 1 30); do
                    if pg_isready -U postgres -h 127.0.0.1 -p 5432 >/dev/null 2>&1; then
                      break
                    fi
                    sleep 2
                  done
                  # Check if database exists, create if not
                  psql -U postgres -d postgres -c "SELECT 1 FROM pg_database WHERE datname='records'" 2>/dev/null | grep -q 1 || createdb -U postgres records 2>/dev/null || true
        securityContext:
          runAsUser: 70
          runAsGroup: 70
          allowPrivilegeEscalation: false
        volumeMounts:
        - { name: data,        mountPath: /var/lib/postgresql }
        - { name: init,        mountPath: /docker-entrypoint-initdb.d }
        - { name: wal-archive, mountPath: /wal-archive }
        - { name: run,         mountPath: /var/run/postgresql }
        args:
          - "-c"
          - "wal_level=replica"
          - "-c"
          - "archive_mode=on"
          - "-c"
          - "archive_command=test ! -f /wal-archive/%f && cp %p /wal-archive/%f"
          - "-c"
          - "archive_timeout=60s"
          - "-c"
          - "max_wal_size=2GB"
          - "-c"
          - "min_wal_size=80MB"
          - "-c"
          - "max_connections=200"
          - "-c"
          - "shared_buffers=1GB"
          - "-c"
          - "effective_cache_size=4GB"
          - "-c"
          - "work_mem=32MB"
          - "-c"
          - "maintenance_work_mem=512MB"
          - "-c"
          - "random_page_cost=1.1"
          - "-c"
          - "cpu_index_tuple_cost=0.0005"
          - "-c"
          - "cpu_tuple_cost=0.01"
          - "-c"
          - "effective_io_concurrency=200"
          - "-c"
          - "max_worker_processes=12"
          - "-c"
          - "max_parallel_workers=12"
          - "-c"
          - "max_parallel_workers_per_gather=4"
          - "-c"
          - "autovacuum_naptime=30s"
          - "-c"
          - "autovacuum_vacuum_scale_factor=0.05"
          - "-c"
          - "autovacuum_analyze_scale_factor=0.02"
          - "-c"
          - "checkpoint_completion_target=0.9"
          - "-c"
          - "checkpoint_timeout=900s"
          - "-c"
          - "jit=off"
          - "-c"
          - "track_io_timing=on"

      volumes:
      - name: data
        persistentVolumeClaim: { claimName: pgdata-big }
      - name: init
        configMap: { name: postgres-init }
      - name: wal-archive
        persistentVolumeClaim: { claimName: pg-wal-archive }
      - name: run
        emptyDir: {}